<?xml version='1.0' encoding='utf-8'?>
<class abstract="true" id="cybozu::tcp_socket" name="tcp_socket" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <brief>A <ref ref="cybozu::resource#cybozu::resource">cybozu::resource</ref> subclass for connected TCP sockets.</brief>
  <doc>This is an abstract base class implementing <ref ref="cybozu::resource#cybozu::resource::on_writable">cybozu::resource::on_writable</ref>
and provides <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::send">send</ref>, <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::sendv">sendv</ref>, <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::send_close">send_close</ref>, and <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::sendv_close">sendv_close</ref> member
functions for connected TCP sockets.

Derived classes still need to implement <ref ref="cybozu::resource#cybozu::resource::on_readable">cybozu::resource::on_readable</ref>.</doc>
  <base access="public">
    <type name="resource" ref="cybozu::resource#cybozu::resource" />
    <brief>An abstraction of a file descriptor.</brief>
  </base>
  <subclass access="public" name="yrmcds::memcache::repl_client_socket" ref="yrmcds::memcache::repl_client_socket#yrmcds::memcache::repl_client_socket" />
  <subclass access="public" name="yrmcds::memcache::repl_socket" ref="yrmcds::memcache::repl_socket#yrmcds::memcache::repl_socket" />
  <subclass access="public" name="yrmcds::memcache::memcache_socket" ref="yrmcds::memcache::memcache_socket#yrmcds::memcache::memcache_socket" />
  <subclass access="public" name="yrmcds::counter::counter_socket" ref="yrmcds::counter::counter_socket#yrmcds::counter::counter_socket" />
  <variable id="cybozu::tcp_socket::MAX_IOVCNT" name="MAX_IOVCNT">
    <brief>The maximum size of <ref ref="cybozu::tcp_socket::iovec#cybozu::tcp_socket::iovec">cybozu::tcp_socket::iovec</ref> array for <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::sendv">cybozu::tcp_socket::sendv</ref>.</brief>
    <type builtin="yes" name="int" qualifier=" const" />
  </variable>
  <struct name="iovec" ref="cybozu::tcp_socket::iovec#cybozu::tcp_socket::iovec">
    <brief>struct for <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::sendv">cybozu::tcp_socket::sendv</ref> and <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::sendv_close">cybozu::tcp_socket::sendv_close</ref>.</brief>
  </struct>
  <constructor abstract="yes" id="cybozu::tcp_socket::tcp_socket" name="tcp_socket">
    <brief>Construct an already connected socket.</brief>
    <doc>Construct a socket resource with a connected socket file descriptor.
The socket should already be set non-blocking.</doc>
    <argument id="cybozu::tcp_socket::tcp_socket::fd" name="fd">
      <doc>A file descriptor of a connected socket.</doc>
      <type builtin="yes" name="int" />
    </argument>
    <argument id="cybozu::tcp_socket::tcp_socket::bufcnt" name="bufcnt">
      <doc>The number of 1 MiB buffers for pending send data.</doc>
      <type builtin="yes" name="unsigned int" />
    </argument>
  </constructor>
  <destructor id="cybozu::tcp_socket::~tcp_socket" name="~tcp_socket" virtual="yes" />
  <method id="cybozu::tcp_socket::send" name="send">
    <brief>Atomically send data.</brief>
    <doc>This function sends a chunk of data atomically.  The reactor
thread should not call this, or it may be blocked forever.

</doc>
    <return>
      <doc>`true` if this socket is valid, `false` otherwise.</doc>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="cybozu::tcp_socket::send::p" name="p">
      <doc>Data to be sent.</doc>
      <type builtin="yes" name="char" qualifier=" const *" />
    </argument>
    <argument id="cybozu::tcp_socket::send::len" name="len">
      <doc>Length of data starting from `p`.</doc>
      <type name="std::size_t" />
    </argument>
    <argument id="cybozu::tcp_socket::send::flush" name="flush">
      <doc>If `true`, the kernel send buffer will be flushed.</doc>
      <type builtin="yes" name="bool" />
    </argument>
  </method>
  <method id="cybozu::tcp_socket::send_close" name="send_close">
    <brief>Atomically send data, then close the socket.</brief>
    <doc>This function sends a chunk of data atomically.  The socket
will be closed after data are sent.  The reactor thread should
not call this, or it may be blocked forever.

</doc>
    <return>
      <doc>`true` if this socket is valid, `false` otherwise.</doc>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="cybozu::tcp_socket::send_close::p" name="p">
      <doc>Data to be sent.</doc>
      <type builtin="yes" name="char" qualifier=" const *" />
    </argument>
    <argument id="cybozu::tcp_socket::send_close::len" name="len">
      <doc>Length of data starting from `p`.</doc>
      <type name="std::size_t" />
    </argument>
  </method>
  <method id="cybozu::tcp_socket::sendv" name="sendv">
    <brief>Atomically send multiple data.</brief>
    <doc>This function sends a chunk of data atomically.  The reactor
thread should not call this, or it may be blocked forever.

</doc>
    <return>
      <doc>`true` if this socket is valid, `false` otherwise.</doc>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="cybozu::tcp_socket::sendv::iov" name="iov">
      <doc>Array of <ref ref="cybozu::tcp_socket::iovec#cybozu::tcp_socket::iovec">cybozu::tcp_socket::iovec</ref>.</doc>
      <type name="iovec" qualifier=" const *" ref="cybozu::tcp_socket::iovec#cybozu::tcp_socket::iovec" />
    </argument>
    <argument id="cybozu::tcp_socket::sendv::iovcnt" name="iovcnt">
      <doc>Number of elements in `iov`.</doc>
      <type builtin="yes" name="int" />
    </argument>
    <argument id="cybozu::tcp_socket::sendv::flush" name="flush">
      <doc>If `true`, the kernel send buffer will be flushed.</doc>
      <type builtin="yes" name="bool" />
    </argument>
  </method>
  <method id="cybozu::tcp_socket::sendv_close" name="sendv_close">
    <brief>Atomically send multiple data, then close the socket.</brief>
    <doc>This function sends a chunk of data atomically.  The socket
will be closed after data are sent.  The reactor thread should
not call this, or it may be blocked forever.

</doc>
    <return>
      <doc>`true` if this socket is valid, `false` otherwise.</doc>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="cybozu::tcp_socket::sendv_close::iov" name="iov">
      <doc>Array of <ref ref="cybozu::tcp_socket::iovec#cybozu::tcp_socket::iovec">cybozu::tcp_socket::iovec</ref>.</doc>
      <type name="iovec" qualifier=" const *" ref="cybozu::tcp_socket::iovec#cybozu::tcp_socket::iovec" />
    </argument>
    <argument id="cybozu::tcp_socket::sendv_close::iovcnt" name="iovcnt">
      <doc>Number of elements in `iov`.</doc>
      <type builtin="yes" name="int" />
    </argument>
  </method>
  <method access="protected" id="cybozu::tcp_socket::on_buffer_full" name="on_buffer_full" virtual="yes">
    <brief>This method will be called everytime when <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::send">cybozu::tcp_socket::send</ref>, <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::sendv">cybozu::tcp_socket::sendv</ref>,</brief>
    <doc><ref ref="cybozu::tcp_socket#cybozu::tcp_socket::send_close">cybozu::tcp_socket::send_close</ref>, or <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::sendv_close">cybozu::tcp_socket::sendv_close</ref> is blocked because of internal buffer full.

Subclasses can override this to handle the buffer full event.</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method access="protected" id="cybozu::tcp_socket::on_invalidate" name="on_invalidate" override="yes" virtual="yes">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <override name="resource::on_invalidate" ref="cybozu::resource#cybozu::resource::on_invalidate" />
  </method>
  <method access="protected" id="cybozu::tcp_socket::on_writable" name="on_writable" override="yes" virtual="yes">
    <brief>Just call <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::write_pending_data">cybozu::tcp_socket::write_pending_data</ref>.</brief>
    <doc>The default implementation just invoke <ref ref="cybozu::tcp_socket#cybozu::tcp_socket::write_pending_data">cybozu::tcp_socket::write_pending_data</ref>.
You may override this to dispatch the job to another thread.</doc>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <override name="resource::on_writable" ref="cybozu::resource#cybozu::resource::on_writable" />
  </method>
  <method abstract="yes" access="protected" id="cybozu::tcp_socket::write_pending_data" name="write_pending_data">
    <brief>Write out pending data.</brief>
    <doc>This method tries to send pending data as much as possible.

</doc>
    <return>
      <doc>`false` if some error happened, `true` otherwise.</doc>
      <type builtin="yes" name="bool" />
    </return>
  </method>
</class>
